<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_markers: scran_markers Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_markers
   </div>
   <div id="projectbrief">Marker detection for single-cell data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran_markers Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Marker detection for single-cell data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html">ScoreMarkersBestOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a3b877db1571dd74a128af35eee5641d3">score_markers_best()</a></code> and friends.  <a href="structscran__markers_1_1ScoreMarkersBestOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1ScoreMarkersBestResults.html">ScoreMarkersBestResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results for <code><a class="el" href="#a3b877db1571dd74a128af35eee5641d3">score_markers_best()</a></code> and friends.  <a href="structscran__markers_1_1ScoreMarkersBestResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html">ScoreMarkersPairwiseBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers for <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> and friends.  <a href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> and friends.  <a href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseResults.html">ScoreMarkersPairwiseResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results for <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> and friends.  <a href="structscran__markers_1_1ScoreMarkersPairwiseResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html">ScoreMarkersSummaryBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers for <code><a class="el" href="#a92c28687f963fbe5535e3fc0c4a60a80">score_markers_summary()</a></code> and friends.  <a href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#a92c28687f963fbe5535e3fc0c4a60a80">score_markers_summary()</a></code> and friends.  <a href="structscran__markers_1_1ScoreMarkersSummaryOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryResults.html">ScoreMarkersSummaryResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results for <code><a class="el" href="#a92c28687f963fbe5535e3fc0c4a60a80">score_markers_summary()</a></code> and friends.  <a href="structscran__markers_1_1ScoreMarkersSummaryResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1SummarizeEffectsOptions.html">SummarizeEffectsOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects()</a></code>.  <a href="structscran__markers_1_1SummarizeEffectsOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1SummaryBuffers.html">SummaryBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointers to arrays to hold the summary statistics.  <a href="structscran__markers_1_1SummaryBuffers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__markers_1_1SummaryResults.html">SummaryResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for the summary statistics.  <a href="structscran__markers_1_1SummaryResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6c63a08774d6f2105b68b656f8a3da94" id="r_a6c63a08774d6f2105b68b656f8a3da94"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Group_ , typename Stat_ &gt; </td></tr>
<tr class="memitem:a6c63a08774d6f2105b68b656f8a3da94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a> &amp;options, const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html">ScoreMarkersPairwiseBuffers</a>&lt; Stat_ &gt; &amp;output)</td></tr>
<tr class="separator:a6c63a08774d6f2105b68b656f8a3da94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5a2571c6f34d150a9b155ebd396a25" id="r_a9c5a2571c6f34d150a9b155ebd396a25"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Group_ , typename Block_ , typename Stat_ &gt; </td></tr>
<tr class="memitem:a9c5a2571c6f34d150a9b155ebd396a25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c5a2571c6f34d150a9b155ebd396a25">score_markers_pairwise_blocked</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const Block_ *const block, const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a> &amp;options, const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html">ScoreMarkersPairwiseBuffers</a>&lt; Stat_ &gt; &amp;output)</td></tr>
<tr class="separator:a9c5a2571c6f34d150a9b155ebd396a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e6a1d4dc2f4bad9e80ebe68eb08ce1" id="r_aa0e6a1d4dc2f4bad9e80ebe68eb08ce1"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Group_ &gt; </td></tr>
<tr class="memitem:aa0e6a1d4dc2f4bad9e80ebe68eb08ce1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseResults.html">ScoreMarkersPairwiseResults</a>&lt; Stat_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa0e6a1d4dc2f4bad9e80ebe68eb08ce1">score_markers_pairwise</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a> &amp;options)</td></tr>
<tr class="separator:aa0e6a1d4dc2f4bad9e80ebe68eb08ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07e111b7e98525a9230937bb5ff61f8" id="r_ab07e111b7e98525a9230937bb5ff61f8"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Group_ , typename Block_ &gt; </td></tr>
<tr class="memitem:ab07e111b7e98525a9230937bb5ff61f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseResults.html">ScoreMarkersPairwiseResults</a>&lt; Stat_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab07e111b7e98525a9230937bb5ff61f8">score_markers_pairwise_blocked</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const Block_ *const block, const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a> &amp;options)</td></tr>
<tr class="separator:ab07e111b7e98525a9230937bb5ff61f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b877db1571dd74a128af35eee5641d3" id="r_a3b877db1571dd74a128af35eee5641d3"><td class="memTemplParams" colspan="2">template&lt;typename Stat_ , typename Value_ , typename Index_ , typename Group_ &gt; </td></tr>
<tr class="memitem:a3b877db1571dd74a128af35eee5641d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__markers_1_1ScoreMarkersBestResults.html">ScoreMarkersBestResults</a>&lt; Stat_, Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b877db1571dd74a128af35eee5641d3">score_markers_best</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, int top, const <a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html">ScoreMarkersBestOptions</a> &amp;options)</td></tr>
<tr class="separator:a3b877db1571dd74a128af35eee5641d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb11bdcf5c54fc4886a20e5f2f003aa2" id="r_afb11bdcf5c54fc4886a20e5f2f003aa2"><td class="memTemplParams" colspan="2">template&lt;typename Stat_ , typename Value_ , typename Index_ , typename Group_ , typename Block_ &gt; </td></tr>
<tr class="memitem:afb11bdcf5c54fc4886a20e5f2f003aa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__markers_1_1ScoreMarkersBestResults.html">ScoreMarkersBestResults</a>&lt; Stat_, Index_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb11bdcf5c54fc4886a20e5f2f003aa2">score_markers_best_blocked</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const Block_ *const block, int top, const <a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html">ScoreMarkersBestOptions</a> &amp;options)</td></tr>
<tr class="separator:afb11bdcf5c54fc4886a20e5f2f003aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefddf4357cc7de227c5242b3861d5a27" id="r_aefddf4357cc7de227c5242b3861d5a27"><td class="memTemplParams" colspan="2">template&lt;typename Gene_ , typename Stat_ , typename Rank_ &gt; </td></tr>
<tr class="memitem:aefddf4357cc7de227c5242b3861d5a27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects</a> (const Gene_ ngenes, const std::size_t ngroups, const Stat_ *const effects, const std::vector&lt; <a class="el" href="structscran__markers_1_1SummaryBuffers.html">SummaryBuffers</a>&lt; Stat_, Rank_ &gt; &gt; &amp;summaries, const <a class="el" href="structscran__markers_1_1SummarizeEffectsOptions.html">SummarizeEffectsOptions</a> &amp;options)</td></tr>
<tr class="separator:aefddf4357cc7de227c5242b3861d5a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae49bdf2cb9840a8dddf919de36107f" id="r_a5ae49bdf2cb9840a8dddf919de36107f"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Rank_  = int, typename Gene_ &gt; </td></tr>
<tr class="memitem:a5ae49bdf2cb9840a8dddf919de36107f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structscran__markers_1_1SummaryResults.html">SummaryResults</a>&lt; Stat_, Rank_ &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5ae49bdf2cb9840a8dddf919de36107f">summarize_effects</a> (const Gene_ ngenes, const std::size_t ngroups, const Stat_ *const effects, const <a class="el" href="structscran__markers_1_1SummarizeEffectsOptions.html">SummarizeEffectsOptions</a> &amp;options)</td></tr>
<tr class="separator:a5ae49bdf2cb9840a8dddf919de36107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c28687f963fbe5535e3fc0c4a60a80" id="r_a92c28687f963fbe5535e3fc0c4a60a80"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Group_ , typename Stat_ , typename Rank_ &gt; </td></tr>
<tr class="memitem:a92c28687f963fbe5535e3fc0c4a60a80"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a92c28687f963fbe5535e3fc0c4a60a80">score_markers_summary</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a> &amp;options, const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html">ScoreMarkersSummaryBuffers</a>&lt; Stat_, Rank_ &gt; &amp;output)</td></tr>
<tr class="separator:a92c28687f963fbe5535e3fc0c4a60a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab817d3509bf11224c5841cee6eb19d26" id="r_ab817d3509bf11224c5841cee6eb19d26"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Group_ , typename Block_ , typename Stat_ , typename Rank_ &gt; </td></tr>
<tr class="memitem:ab817d3509bf11224c5841cee6eb19d26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab817d3509bf11224c5841cee6eb19d26">score_markers_summary_blocked</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const Block_ *const block, const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a> &amp;options, const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html">ScoreMarkersSummaryBuffers</a>&lt; Stat_, Rank_ &gt; &amp;output)</td></tr>
<tr class="separator:ab817d3509bf11224c5841cee6eb19d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9b15716f2c1a1d9d9add3d12319c7b" id="r_a2c9b15716f2c1a1d9d9add3d12319c7b"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Rank_  = int, typename Value_ , typename Index_ , typename Group_ &gt; </td></tr>
<tr class="memitem:a2c9b15716f2c1a1d9d9add3d12319c7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryResults.html">ScoreMarkersSummaryResults</a>&lt; Stat_, Rank_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2c9b15716f2c1a1d9d9add3d12319c7b">score_markers_summary</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a> &amp;options)</td></tr>
<tr class="separator:a2c9b15716f2c1a1d9d9add3d12319c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5621dc5ac02a137bee6fab5c1c84e0" id="r_a3c5621dc5ac02a137bee6fab5c1c84e0"><td class="memTemplParams" colspan="2">template&lt;typename Stat_  = double, typename Rank_  = int, typename Value_ , typename Index_ , typename Group_ , typename Block_ &gt; </td></tr>
<tr class="memitem:a3c5621dc5ac02a137bee6fab5c1c84e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryResults.html">ScoreMarkersSummaryResults</a>&lt; Stat_, Rank_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c5621dc5ac02a137bee6fab5c1c84e0">score_markers_summary_blocked</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;matrix, const Group_ *const group, const Block_ *const block, const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a> &amp;options)</td></tr>
<tr class="separator:a3c5621dc5ac02a137bee6fab5c1c84e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Marker detection for single-cell data. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3b877db1571dd74a128af35eee5641d3" name="a3b877db1571dd74a128af35eee5641d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b877db1571dd74a128af35eee5641d3">&#9670;&#160;</a></span>score_markers_best()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_ , typename Value_ , typename Index_ , typename Group_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__markers_1_1ScoreMarkersBestResults.html">ScoreMarkersBestResults</a>&lt; Stat_, Index_ &gt; scran_markers::score_markers_best </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>top</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html">ScoreMarkersBestOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find potential marker genes with the largest effect sizes in each pairwise comparison between groups. This function is equivalent to (but more efficient than) running <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> and then using <code><a class="elRef" href="https://libscran.github.io/topicks/namespacetopicks.html#afb96918e66418b1d67caca308c3acc98">topicks::pick_top_genes()</a></code> on the effect sizes from each pairwise comparison. The idea is to identify the top markers without a large memory allocation to hold the 3D array of effect sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the statistics. </td></tr>
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">top</td><td>Number of top genes to retain from each pairwise comparison. The actual number of retained genes may be less than or greater than <code>top</code> depending on the number of rows in <code>matrix</code> and the choices of <code><a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html#aec6ceabe769286d92169913b28070ea9">ScoreMarkersBestOptions::keep_ties</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html#a929083a4a766df5e2703b40e135be433">ScoreMarkersBestOptions::threshold_cohens_d</a></code>, etc. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing the top markers from each pairwise comparison. </dd></dl>

</div>
</div>
<a id="afb11bdcf5c54fc4886a20e5f2f003aa2" name="afb11bdcf5c54fc4886a20e5f2f003aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb11bdcf5c54fc4886a20e5f2f003aa2">&#9670;&#160;</a></span>score_markers_best_blocked()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_ , typename Value_ , typename Index_ , typename Group_ , typename Block_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__markers_1_1ScoreMarkersBestResults.html">ScoreMarkersBestResults</a>&lt; Stat_, Index_ &gt; scran_markers::score_markers_best_blocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *const</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>top</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html">ScoreMarkersBestOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find potential marker genes with the largest effect sizes in each pairwise comparison between groups, after accounting for any blocking factor in the dataset. This function is equivalent to (but more efficient than) running <code><a class="el" href="#a9c5a2571c6f34d150a9b155ebd396a25">score_markers_pairwise_blocked()</a></code> and then using <code><a class="elRef" href="https://libscran.github.io/topicks/namespacetopicks.html#afb96918e66418b1d67caca308c3acc98">topicks::pick_top_genes()</a></code> on the effect sizes from each pairwise comparison. The idea is to identify the top markers without a large memory allocation to hold the 3D array of effect sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the statistics. </td></tr>
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type of the block assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the blocking factor. Block identifiers should be 0-based and should contain all integers in \([0, B)\) where \(B\) is the number of unique blocking levels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">top</td><td>Number of top genes to retain from each pairwise comparison. The actual number of retained genes may be less than or greater than <code>top</code> depending on the number of rows in <code>matrix</code> and the choices of <code><a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html#aec6ceabe769286d92169913b28070ea9">ScoreMarkersBestOptions::keep_ties</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersBestOptions.html#a929083a4a766df5e2703b40e135be433">ScoreMarkersBestOptions::threshold_cohens_d</a></code>, etc. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing the top markers with the largest effect sizes from each pairwise comparison. </dd></dl>

</div>
</div>
<a id="aa0e6a1d4dc2f4bad9e80ebe68eb08ce1" name="aa0e6a1d4dc2f4bad9e80ebe68eb08ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e6a1d4dc2f4bad9e80ebe68eb08ce1">&#9670;&#160;</a></span>score_markers_pairwise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Group_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseResults.html">ScoreMarkersPairwiseResults</a>&lt; Stat_ &gt; scran_markers::score_markers_pairwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> that allocates memory for the output statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the statistics. </td></tr>
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing the pairwise effects, plus the mean expression and detected proportion in each group. </dd></dl>

</div>
</div>
<a id="a6c63a08774d6f2105b68b656f8a3da94" name="a6c63a08774d6f2105b68b656f8a3da94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c63a08774d6f2105b68b656f8a3da94">&#9670;&#160;</a></span>score_markers_pairwise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Group_ , typename Stat_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_markers::score_markers_pairwise </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html">ScoreMarkersPairwiseBuffers</a>&lt; Stat_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Score potential marker genes based on the effect sizes for the pairwise comparisons between groups. For each group, the strongest markers are those genes with the largest effect sizes (i.e., upregulated) when compared to all other groups. The pairwise effect sizes computed by this function can be used to identify markers to distinguish two specific groups, or the effect sizes for multiple comparisons involving a group can be passed to <code><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects()</a></code> to obtain a single ranking for that group.</p>
<h1><a class="anchor" id="effect-sizes"></a>
Choice of effect size</h1>
<p>The delta-mean is the difference in the mean expression between groups. This is fairly straightforward to interpret - a positive delta-mean corresponds to increased expression in the first group compared to the second. The delta-mean can also be treated as the log-fold change if the input matrix contains log-transformed normalized expression values.</p>
<p>The delta-detected is the difference in the proportion of cells with detected expression between groups. This lies between 1 and -1, with the extremes occurring when a gene is silent in one group and detected in all cells of the other group. For this interpretation, we assume that the input matrix contains non-negative expression values, where a value of zero corresponds to lack of detectable expression.</p>
<p>Cohen's d is the standardized difference between two groups. This is defined as the difference in the mean for each group scaled by the average standard deviation across the two groups. (Technically, we should use the pooled variance; however, this introduces some unintuitive asymmetry depending on the variance of the larger group, so we take a simple average instead.) A positive value indicates that the gene has increased expression in the first group compared to the second. Cohen's d is analogous to the t-statistic in a two-sample t-test and avoids spuriously large effect sizes from comparisons between highly variable groups. We can also interpret Cohen's d as the number of standard deviations between the two group means.</p>
<p>The area under the curve (AUC) is the probability that a randomly chosen observation in one group is greater than a randomly chosen observation in the other group. Values greater than 0.5 indicate that a gene is upregulated in the first group. The AUC is closely related to the U-statistic used in the Wilcoxon rank sum test. The key difference between the AUC and Cohen's d is that the former is less sensitive to the variance within each group, e.g., if two distributions exhibit no overlap, the AUC is the same regardless of the variance of each distribution. This may or may not be desirable as it improves robustness to outliers but reduces the information available to obtain a fine-grained ranking.</p>
<h1><a class="anchor" id="threshold"></a>
With a minimum change threshold</h1>
<p>Setting a minimum change threshold (<code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html#a507dbb049c6a0412fbecebf245c77a57">ScoreMarkersPairwiseOptions::threshold</a></code>) prioritizes genes with large shifts in expression instead of those with low variances. Currently, only positive thresholds are supported, which focuses on genes that are upregulated in the first group compared to the second. The effect size definitions are generalized when testing against a non-zero threshold:</p>
<ul>
<li>Cohen's d is redefined as the standardized difference between the difference in means and the specified threshold, analogous to the TREAT method from the <a href="https://bioconductor.org/packages/limma"><b>limma</b></a> R/Bioconductor package. Large positive values are only obtained when the observed difference in means is significantly greater than the threshold. For example, if we had a threshold of 2 and we obtained a Cohen's d of 3, this means that the observed difference in means was 3 standard deviations greater than 2. Note that a negative Cohen's d cannot be intepreted as downregulation, as the difference in means may still be positive but less than the threshold.</li>
<li>The AUC is generalized to the probability of obtaining a random observation in one group that is greater than a random observation plus the threshold in the other group. For example, if we had a threshold of 2 and we obtained an AUC of 0.8, this means that, 80% of the time, the random observation from the first group would be greater than a random observation from the second group by 2 or more. Again, AUCs below 0.5 cannot be interpreted as downregulation, as it may be caused by a positive shift that is less than the threshold.</li>
</ul>
<h1><a class="anchor" id="other"></a>
Other statistics</h1>
<p>We report the mean expression of all cells in each group as well as the proportion of cells with detectable expression in each group. These statistics are useful for quickly interpreting the differences in expression driving the effect sizes.</p>
<p>The effect sizes for all comparisons involving a particular group can be summarized into a few key statistics with <code><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects()</a></code>. Ranking by a selected summary statistic can identify candidate markers for the group of interest compared to any, some or all other groups. See also <code><a class="el" href="#a92c28687f963fbe5535e3fc0c4a60a80">score_markers_summary()</a></code>, to efficiently obtain effect size summaries for each group.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Collection of buffers in which to store the computed statistics. Each buffer is filled with the corresponding statistic for each group or pairwise comparison. Any of <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#a09a285a84e5ba22649d5aa0d87b2a21b">ScoreMarkersPairwiseBuffers::cohens_d</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#ab052f7be5c0597a28f2372614a5bb3d7">ScoreMarkersPairwiseBuffers::auc</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#a04fba49f4046f6ecc61edbc73ea3d546">ScoreMarkersPairwiseBuffers::delta_mean</a></code> or <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#a828364f6541a2c0ca63e9d05e020affc">ScoreMarkersPairwiseBuffers::delta_detected</a></code> may be NULL, in which case the corresponding statistic is not computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab07e111b7e98525a9230937bb5ff61f8" name="ab07e111b7e98525a9230937bb5ff61f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07e111b7e98525a9230937bb5ff61f8">&#9670;&#160;</a></span>score_markers_pairwise_blocked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Value_ , typename Index_ , typename Group_ , typename Block_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseResults.html">ScoreMarkersPairwiseResults</a>&lt; Stat_ &gt; scran_markers::score_markers_pairwise_blocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *const</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a9c5a2571c6f34d150a9b155ebd396a25">score_markers_pairwise_blocked()</a></code> that allocates memory for the output statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the statistics. </td></tr>
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type of the block assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the blocking factor. Block identifiers should be 0-based and should contain all integers in \([0, B)\) where \(B\) is the number of unique blocking levels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing the pairwise effects, plus the mean expression and detected proportion in each group. </dd></dl>

</div>
</div>
<a id="a9c5a2571c6f34d150a9b155ebd396a25" name="a9c5a2571c6f34d150a9b155ebd396a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5a2571c6f34d150a9b155ebd396a25">&#9670;&#160;</a></span>score_markers_pairwise_blocked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Group_ , typename Block_ , typename Stat_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_markers::score_markers_pairwise_blocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *const</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html">ScoreMarkersPairwiseOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html">ScoreMarkersPairwiseBuffers</a>&lt; Stat_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Score potential marker genes as described for <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> after accounting for any blocking factor in the dataset. Comparisons are only performed between the groups of cells in the same level of the blocking factor. The batch-specific effect sizes are then combined into a single aggregate value for output. This strategy avoids most problems related to batch effects as we never directly compare across different blocking levels.</p>
<p>Specifically, for each gene and each pair of groups, we obtain one effect size per blocking level. We consolidate these into a single statistic by computing the weighted mean across levels. The weight for each level is defined as the product of the weights of the two groups involved in the comparison, where each weight is derived from the size of the group using the policy in <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html#a24f56fd20bed4003ea896ee379735343">ScoreMarkersPairwiseOptions::block_weight_policy</a></code>.</p>
<p>Blocking levels with no cells in either group will not contribute anything to the weighted mean. If two groups never co-occur in the same blocking level, no effect size will be computed and a <code>NaN</code> is reported in the output. We do not attempt to reconcile batch effects in a partially confounded scenario.</p>
<p>For the mean and detected proportion in each group, we compute a weighted average of each statistic across blocks for each gene. Again, the weight for each group is derived from the size of that group using the policy in <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseOptions.html#a24f56fd20bed4003ea896ee379735343">ScoreMarkersPairwiseOptions::block_weight_policy</a></code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type of the block assignments. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the blocking factor. Block identifiers should be 0-based and should contain all integers in \([0, B)\) where \(B\) is the number of unique blocking levels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Collection of buffers in which to store the computed statistics. Each buffer is filled with the corresponding statistic for each group or pairwise comparison. Any of <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#a09a285a84e5ba22649d5aa0d87b2a21b">ScoreMarkersPairwiseBuffers::cohens_d</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#ab052f7be5c0597a28f2372614a5bb3d7">ScoreMarkersPairwiseBuffers::auc</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#a04fba49f4046f6ecc61edbc73ea3d546">ScoreMarkersPairwiseBuffers::delta_mean</a></code> or <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#a828364f6541a2c0ca63e9d05e020affc">ScoreMarkersPairwiseBuffers::delta_detected</a></code> may be NULL, in which case the corresponding statistic is not computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c9b15716f2c1a1d9d9add3d12319c7b" name="a2c9b15716f2c1a1d9d9add3d12319c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9b15716f2c1a1d9d9add3d12319c7b">&#9670;&#160;</a></span>score_markers_summary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Rank_  = int, typename Value_ , typename Index_ , typename Group_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryResults.html">ScoreMarkersSummaryResults</a>&lt; Stat_, Rank_ &gt; scran_markers::score_markers_summary </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> that allocates memory for the output statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type to store the statistics. </td></tr>
    <tr><td class="paramname">Rank_</td><td>Numeric type to store the minimum rank. </td></tr>
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing the summary statistics and the other per-group statistics. </dd></dl>

</div>
</div>
<a id="a92c28687f963fbe5535e3fc0c4a60a80" name="a92c28687f963fbe5535e3fc0c4a60a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c28687f963fbe5535e3fc0c4a60a80">&#9670;&#160;</a></span>score_markers_summary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Group_ , typename Stat_ , typename Rank_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_markers::score_markers_summary </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html">ScoreMarkersSummaryBuffers</a>&lt; Stat_, Rank_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Score each gene as a candidate marker for each group of cells, based on summaries of effect sizes from pairwise comparisons between groups.</p>
<p>Markers are identified by differential expression analyses between pairs of groups of cells (e.g., clusters, cell types). Given \(N\) groups, each group is involved in \(N - 1\) pairwise comparisons and thus has \(N - 1\) effect sizes for each gene. We summarize each group's effect sizes into a small set of desriptive statistics like the minimum, median or mean. Users can then sort genes by any of these summaries to obtain a ranking of potential markers for the group.</p>
<p>The choice of effect size and summary statistic determines the characteristics of the marker ranking. The effect sizes include Cohen's d, the area under the curve (AUC), the delta-mean and the delta-detected (see <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code>). The summary statistics include the minimum, mean, median, maximum and min-rank of the effect sizes across each group's pairwise comparisons (see <code><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects()</a></code>). For example, ranking by the delta-detected with the minimum summary will promote markers that are silent in every other group.</p>
<p>This behavior of this function is equivalent to - but more efficient than - calling <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> followed by <code><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects()</a></code> on each array of effect sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Floating-point type to store the statistics. </td></tr>
    <tr><td class="paramname">Rank_</td><td>Numeric type to store the minimum rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Collection of buffers in which to store the computed statistics. Each buffer is filled with the corresponding statistic for each group or pairwise comparison. Any of <code><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#ab2e2b1bde6d2b563ba95b91264a4538d">ScoreMarkersSummaryBuffers::cohens_d</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#ad52aeadb45b041450c92ca4036ca39f0">ScoreMarkersSummaryBuffers::auc</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#a9e2ed3d8b7a36bc5c8269a690f1e36c2">ScoreMarkersSummaryBuffers::delta_mean</a></code> or <code><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#a7e5396d3a6530d20258ce45181e81ef9">ScoreMarkersSummaryBuffers::delta_detected</a></code> may be empty, in which case the corresponding statistic is not computed or summarized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c5621dc5ac02a137bee6fab5c1c84e0" name="a3c5621dc5ac02a137bee6fab5c1c84e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5621dc5ac02a137bee6fab5c1c84e0">&#9670;&#160;</a></span>score_markers_summary_blocked() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Rank_  = int, typename Value_ , typename Index_ , typename Group_ , typename Block_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryResults.html">ScoreMarkersSummaryResults</a>&lt; Stat_, Rank_ &gt; scran_markers::score_markers_summary_blocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *const</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#a9c5a2571c6f34d150a9b155ebd396a25">score_markers_pairwise_blocked()</a></code> that allocates memory for the output statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stat_</td><td>Floating-point type to store the statistics. </td></tr>
    <tr><td class="paramname">Rank_</td><td>Numeric type to store the minimum rank. </td></tr>
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type of the block assignments.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the blocking factor. Block identifiers should be 0-based and should contain all integers in \([0, B)\) where \(B\) is the number of unique blocking levels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Object containing the pairwise effects, plus the mean expression and detected proportion in each group. </dd></dl>

</div>
</div>
<a id="ab817d3509bf11224c5841cee6eb19d26" name="ab817d3509bf11224c5841cee6eb19d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab817d3509bf11224c5841cee6eb19d26">&#9670;&#160;</a></span>score_markers_summary_blocked() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Group_ , typename Block_ , typename Stat_ , typename Rank_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_markers::score_markers_summary_blocked </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Group_ *const</td>          <td class="paramname"><span class="paramname"><em>group</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *const</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryOptions.html">ScoreMarkersSummaryOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html">ScoreMarkersSummaryBuffers</a>&lt; Stat_, Rank_ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>output</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Score potential marker genes by computing summary statistics across pairwise comparisons between groups, accounting for any blocking factor in the dataset. Comparisons are only performed between the groups of cells in the same level of the blocking factor, as described in <code><a class="el" href="#a9c5a2571c6f34d150a9b155ebd396a25">score_markers_pairwise_blocked()</a></code>. This strategy avoids most problems related to batch effects as we never directly compare across different blocking levels. The block-specific effect sizes are combined into a single aggregate value per comparison, which are in turn summarized as described in <code><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects()</a></code>. This behavior of this function is equivalent to - but more efficient than - calling <code><a class="el" href="#a9c5a2571c6f34d150a9b155ebd396a25">score_markers_pairwise_blocked()</a></code> followed by <code><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects()</a></code> on each array of effect sizes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Matrix data type. </td></tr>
    <tr><td class="paramname">Index_</td><td>Matrix index type. </td></tr>
    <tr><td class="paramname">Group_</td><td>Integer type of the group assignments. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Floating-point type to store the statistics. </td></tr>
    <tr><td class="paramname">Rank_</td><td>Numeric type to store the minimum rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">matrix</td><td>A matrix of expression values, typically normalized and log-transformed. Rows should contain genes while columns should contain cells. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the group assignments. Group identifiers should be 0-based and should contain all integers in \([0, N)\) where \(N\) is the number of unique groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of columns in <code>matrix</code>, containing the blocking factor. Block identifiers should be 0-based and should contain all integers in \([0, B)\) where \(B\) is the number of unique blocking levels. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>Collection of buffers in which to store the computed statistics. Each buffer is filled with the corresponding statistic for each group or pairwise comparison. Any of <code><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#ab2e2b1bde6d2b563ba95b91264a4538d">ScoreMarkersSummaryBuffers::cohens_d</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#ad52aeadb45b041450c92ca4036ca39f0">ScoreMarkersSummaryBuffers::auc</a></code>, <code><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#a9e2ed3d8b7a36bc5c8269a690f1e36c2">ScoreMarkersSummaryBuffers::delta_mean</a></code> or <code><a class="el" href="structscran__markers_1_1ScoreMarkersSummaryBuffers.html#a7e5396d3a6530d20258ce45181e81ef9">ScoreMarkersSummaryBuffers::delta_detected</a></code> may be empty, in which case the corresponding statistic is not computed or summarized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefddf4357cc7de227c5242b3861d5a27" name="aefddf4357cc7de227c5242b3861d5a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefddf4357cc7de227c5242b3861d5a27">&#9670;&#160;</a></span>summarize_effects() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Gene_ , typename Stat_ , typename Rank_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_markers::summarize_effects </td>
          <td>(</td>
          <td class="paramtype">const Gene_</td>          <td class="paramname"><span class="paramname"><em>ngenes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>ngroups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Stat_ *const</td>          <td class="paramname"><span class="paramname"><em>effects</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structscran__markers_1_1SummaryBuffers.html">SummaryBuffers</a>&lt; Stat_, Rank_ &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>summaries</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1SummarizeEffectsOptions.html">SummarizeEffectsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given \(N\) groups, each group is involved in \(N - 1\) pairwise comparisons and thus has \(N - 1\) effect sizes (e.g., as computed by <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code>). We summarize each group's effect sizes into a small set of desriptive statistics like the mininum, median or mean. Users can then sort genes by any of these summaries to obtain a ranking of potential markers for that group.</p>
<p>The choice of summary statistic determines the interpretation of the ranking. Given a group \(X\):</p>
<ul>
<li>A large mean effect size indicates that the gene is upregulated in \(X\) compared to the average of the other groups. A small value indicates that the gene is downregulated in \(X\) instead. This is a good general-purpose summary statistic that can be ranked in descending order to obtain the strongest upregulated markers in \(X\).</li>
<li>A large median effect size indicates that the gene is upregulated in \(X\) compared to most (&gt;50%) other groups. A small value indicates that the gene is downregulated in \(X\) instead. This is also a good general-purpose summary like the mean, with the advantage of being more robust to outlier effects compared to the mean. However, it also has the disadvantage of being less sensitive to strong effects in a minority of comparisons.</li>
<li>A large minimum effect size indicates that the gene is upregulated in \(X\) compared to all other groups. A small value indicates that the gene is downregulated in \(X\) compared to at least one other group. For upregulation, this is the most stringent summary as markers will only have extreme values if they are <em>uniquely</em> upregulated in \(X\) compared to every other group. However, it may not be effective if \(X\) is closely related to any of the groups.</li>
<li>A large maximum effect size indicates that the gene is upregulated in \(X\) compared to at least one other group. A small value indicates that the gene is downregulated in \(X\) compared to all other groups. For downregulation, this is the most stringent summary as markers will only have extreme values if they are <em>uniquely</em> downregulated in \(X\) compared to every other group. However, it may not be effective if \(X\) is closely related to any of the groups.</li>
<li>The "minimum rank" (a.k.a., min-rank) is defined by ranking genes based on decreasing effect size <em>within</em> each comparison involving \(X\), and then taking the smallest rank for each gene <em>across</em> all comparisons involving \(X\). A minimum rank of 1 means that the gene is the top upregulated gene in at least one comparison to another group. More generally, a minimum rank of \(T\) indicates that the gene is the \(T\)-th upregulated gene in at least one comparison. Applying a threshold on the minimum rank is useful for obtaining a set of genes that, in combination, are guaranteed to distinguish \(X\) from every other group.</li>
</ul>
<p>The exact definition of "large" and "small" depends on the choice of effect size. For signed effects like Cohen's d, delta-mean and delta-detected, the value must be positive to be considered "large", and negative to be considered "small". For the AUC, a value greater than 0.5 is considered "large" and less than 0.5 is considered "small".</p>
<p>The interpretation above is also contingent on the threshold used (see <code><a class="el" href="#a6c63a08774d6f2105b68b656f8a3da94">score_markers_pairwise()</a></code> for details). For positive thresholds, small summary statistics cannot be unambiguously interpreted as downregulation, as the effect is already adjusted to account for the threshold. Only large summary statistics can be safely interpreted, i.e., as evidence for upregulation.</p>
<p>NaN effect sizes are allowed, e.g., if two groups do not exist in the same block for a blocked analysis in <code><a class="el" href="#a9c5a2571c6f34d150a9b155ebd396a25">score_markers_pairwise_blocked()</a></code>. This class will ignore NaN values when computing each summary. If all effects are NaN for a particular group, the summary statistic will also be <code>NaN</code>.</p>
<p>All choices of summary statistics are enumerated by <code>Summary</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Gene_</td><td>Integer type of the number of genes. </td></tr>
    <tr><td class="paramname">Stat_</td><td>Floating-point type of the statistics. </td></tr>
    <tr><td class="paramname">Rank_</td><td>Numeric type of the minimum rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ngenes</td><td>Number of genes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ngroups</td><td>Number of groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">effects</td><td>Pointer to a 3-dimensional array containing the pairwise statistics, see <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#a09a285a84e5ba22649d5aa0d87b2a21b">ScoreMarkersPairwiseBuffers::cohens_d</a></code> for the expected contents. The entry \((i, j, k)\) (i.e., <code>effects[i * N * N + j * N + k]</code>) represents the effect size of gene \(i\) upon comparing group \(j\) against group \(k\). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">summaries</td><td>Vector of length equal to the number of groups. Each entry corresponds to a group and is used to store the summary statistics for that group. Each pointer in any given <code><a class="el" href="structscran__markers_1_1SummaryBuffers.html" title="Pointers to arrays to hold the summary statistics.">SummaryBuffers</a></code> should either point to an array of length equal to the number of genes, or be <code>NULL</code> to indicate that the corresponding summary statistic should not be computed for that group. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ae49bdf2cb9840a8dddf919de36107f" name="a5ae49bdf2cb9840a8dddf919de36107f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae49bdf2cb9840a8dddf919de36107f">&#9670;&#160;</a></span>summarize_effects() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Stat_  = double, typename Rank_  = int, typename Gene_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structscran__markers_1_1SummaryResults.html">SummaryResults</a>&lt; Stat_, Rank_ &gt; &gt; scran_markers::summarize_effects </td>
          <td>(</td>
          <td class="paramtype">const Gene_</td>          <td class="paramname"><span class="paramname"><em>ngenes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t</td>          <td class="paramname"><span class="paramname"><em>ngroups</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Stat_ *const</td>          <td class="paramname"><span class="paramname"><em>effects</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__markers_1_1SummarizeEffectsOptions.html">SummarizeEffectsOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="#aefddf4357cc7de227c5242b3861d5a27">summarize_effects()</a></code> that allocates memory for the output summary statistics.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Gene_</td><td>Integer type of the number of genes. </td></tr>
    <tr><td class="paramname">Stat</td><td>Floating point type of the statistics. </td></tr>
    <tr><td class="paramname">Rank_</td><td>Numeric type of the minimum rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">ngenes</td><td>Number of genes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ngroups</td><td>Number of groups. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">effects</td><td>Pointer to a 3-dimensional array containing the pairwise statistics, see <code><a class="el" href="structscran__markers_1_1ScoreMarkersPairwiseBuffers.html#a09a285a84e5ba22649d5aa0d87b2a21b">ScoreMarkersPairwiseBuffers::cohens_d</a></code> for the expected contents. The entry \((i, j, k)\) (i.e., <code>effects[i * N * N + j * N + k]</code>) represents the effect size of gene \(i\) upon comparing group \(j\) against group \(k\). </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of length equal to the number of groups. Each <code><a class="el" href="structscran__markers_1_1SummaryResults.html" title="Container for the summary statistics.">SummaryResults</a></code> corresponds to a group and contains the summary statistics (depending on <code>options</code>) for that group. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
